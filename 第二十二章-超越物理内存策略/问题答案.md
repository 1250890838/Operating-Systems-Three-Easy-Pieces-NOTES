1. 使用以下参数生成随机地址：-s 0 -n 10,-s 1 -n 10和-s 2 -n 10.将策略从FIFO更改为LRU,并将其更改为OPT.计算所述地址追踪中的每个访问是否命中或未命中。

```
❯ python2 paging-policy.py -s 0 -n 10
ARG policy FIFO
ARG cachesize 3
....

Access: 8  Hit/Miss?  State of Memory?
Access: 7  Hit/Miss?  State of Memory?
Access: 4  Hit/Miss?  State of Memory?
Access: 2  Hit/Miss?  State of Memory?
Access: 5  Hit/Miss?  State of Memory?
Access: 4  Hit/Miss?  State of Memory?
Access: 7  Hit/Miss?  State of Memory?
Access: 3  Hit/Miss?  State of Memory?
Access: 4  Hit/Miss?  State of Memory?
Access: 5  Hit/Miss?  State of Memory?
```

答案:
```
Access: 8  Miss  State of Memory:[8]
Access: 7  Miss  State of Memory:[8,7]
Access: 4  Miss  State of Memory:[8,7,4]
Access: 2  Miss  State of Memory:[7,4,2]
Access: 5  Miss  State of Memory:[4,2,5]
Access: 4  Hit   State of Memory:[4,2,5]
Access: 7  Miss  State of Memory:[2,5,7]
Access: 3  Miss  State of Memory:[5,7,3]
Access: 4  Miss  State of Memory:[7,3,4]
Access: 5  Miss  State of Memory:[3,4,5]
```

```
❯ python2 paging-policy.py -s 1 -n 10
ARG policy FIFO
ARG cachesize 3

...

Access: 1  Hit/Miss?  State of Memory?
Access: 8  Hit/Miss?  State of Memory?
Access: 7  Hit/Miss?  State of Memory?
Access: 2  Hit/Miss?  State of Memory?
Access: 4  Hit/Miss?  State of Memory?
Access: 4  Hit/Miss?  State of Memory?
Access: 6  Hit/Miss?  State of Memory?
Access: 7  Hit/Miss?  State of Memory?
Access: 0  Hit/Miss?  State of Memory?
Access: 0  Hit/Miss?  State of Memory?
```


答案:
```
Access: 1  Miss  State of Memory:[1]
Access: 8  Miss  State of Memory:[1,8]
Access: 7  Miss  State of Memory:[1,8,7]
Access: 2  Miss  State of Memory:[8,7,2]
Access: 4  Miss  State of Memory:[7,2,4]
Access: 4  Hit   State of Memory:[7,2,4]
Access: 6  Miss  State of Memory:[2,4,6]
Access: 7  Miss  State of Memory:[4,6,7]
Access: 0  Miss  State of Memory:[6,7,0]
Access: 0  Hit   State of Memory:[6,7,0]
```


```
❯ python2 paging-policy.py -s 2 -n 10
ARG policy FIFO
ARG cachesize 3

......

Access: 9  Hit/Miss?  State of Memory?
Access: 9  Hit/Miss?  State of Memory?
Access: 0  Hit/Miss?  State of Memory?
Access: 0  Hit/Miss?  State of Memory?
Access: 8  Hit/Miss?  State of Memory?
Access: 7  Hit/Miss?  State of Memory?
Access: 6  Hit/Miss?  State of Memory?
Access: 3  Hit/Miss?  State of Memory?
Access: 6  Hit/Miss?  State of Memory?
Access: 6  Hit/Miss?  State of Memory?
```

答案:
```
Access: 9  Miss  State of Memory:[9]
Access: 9  Hit   State of Memory:[9]
Access: 0  Miss  State of Memory:[9,0]
Access: 0  Hit   State of Memory:[9,0]
Access: 8  Miss  State of Memory:[9,0,8]
Access: 7  Miss  State of Memory:[0,8,7]
Access: 6  Miss  State of Memory:[8,7,6]
Access: 3  Miss  State of Memory:[7,6,3]
Access: 6  Hit   State of Memory:[7,6,3]
Access: 6  Hit   State of Memory:[7,6,3]
```

2. 对于大小为5的高速缓存，为以下每个策略生成最差情况的地址引用序列：FIFO、LRU和MRU(最差情况下的引用序列导致尽可能多的未命中）。
对于最差情况下的引用序列，需要的缓存增大多少，才能大幅提高性能，并接近OPT?

FIFO:
```
python2 paging-policy.py -a 1,2,3,4,5,6,7,8 -C 5
```

LRU:
```
python2 paging-policy.py -a 1,2,3,4,5,6,7,8 -C 5 -p LRU
```

MRU:
```
python2 paging-policy.py -a 1,2,3,4,5,6,7,8 -C 5 -p MRU
```

最差情况需要缓存增大到与页号相同

3. 生成一个随机追踪序列（使用Python或Perl).你预计不同的策略在这样的追踪序列上的表现如何？

```
❯ python2 paging-policy.py -s 0 -n 10 -c -p FIFO
FINALSTATS hits 1   misses 9   hitrate 10.00
```

```
❯ python2 paging-policy.py -s 0 -n 10 -c -p LRU
FINALSTATS hits 2   misses 8   hitrate 20.00
```

```
❯ python2 paging-policy.py -s 0 -n 10 -c -p OPT
FINALSTATS hits 4   misses 6   hitrate 40.00
```

```
❯ python2 paging-policy.py -s 0 -n 10 -c -p UNOPT
FINALSTATS hits 0   misses 10   hitrate 0.00
```

```
❯ python2 paging-policy.py -s 0 -n 10 -c -p RAND
FINALSTATS hits 0   misses 10   hitrate 0.00
```

```
❯ python2 paging-policy.py -s 0 -n 10 -c -p CLOCK
FINALSTATS hits 1   misses 9   hitrate 10.00
```

4. 现在生成一些局部性追踪序列。如何能够产生这样的追踪序列？LRU表现如何？RAND比LRU好多少？CLOCK表现如何？CLOCK 使用不同数量的时钟位，表现如何？

*译者注:-a参数序列里,逗号后不能有空格,比如-a 1,2,3可以,但-a 1, 2, 3不行*

tool.py用法
```
python3 tool.py -s#产生具有空间局部性序列
python3 tool.py -t#产生具有时间局部性序列
```

答案:
```
python2 paging-policy.py -p LRU -c -a  $(python3 tool.py -t)
python2 paging-policy.py -p LRU -c -a  $(python3 tool.py -s)

python2 paging-policy.py -p RAND -c -a  $(python3 tool.py -t)
python2 paging-policy.py -p RAND -c -a  $(python3 tool.py -s)

python2 paging-policy.py -p CLOCK -c -a  $(python3 tool.py -t)
python2 paging-policy.py -p CLOCK -c -a  $(python3 tool.py -s)
```




5. 使用像 valgrind 这样的程序来测试真实应用程序并生成虚拟页面引用序列。例如，运行valgrind --tool=lackey --trace-mem=yes ls 将为程序1s所做的每个指令和数据引用，
输出近乎完整的引用追踪。为了使上述仿真器有用，你必须首先将每个虚拟内存引用转换为虚拟页码引用(通过屏蔽偏移量并向右移位来完成)。为了满足大部分请求，你的应用程序追踪需要多大的缓
存？随着缓存大小的增加绘制其工作集的图形。

运行:
```
valgrind --tool=lackey --trace-mem=yes ls &> test.txt
```
PC使用64为地址空间,
且默认页大小为4K(2**12),

PDIndex 为12位,因此,得到的偏移地址直接偏移52位即可
(实际打印的地址为32为,因此只要偏移20位即可)