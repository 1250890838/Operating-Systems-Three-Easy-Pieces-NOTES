1.首先用标志- flag.s运行x86.py。该代码通过一个内存标志“实现”锁。你能理解
汇编代码试图做什么吗?
2.使用默认值运行时, flag是否按预期工作?
它会产生正确的结果吗?使用M和-R标志跟踪变量和寄存器(并打开c查看它们的
值)。你能预测代码运行时标志最终会变成什么值吗?
3.使用-a标志更改寄存器%bx的值(例如,如果只运行两个线程,就用-abx=2,bx=
2)。代码是做什么的?对这段代码问上面的问题,答案如何?
4.对每个线程将bx设置为高值,然后使用-标志生成不同的中断频率。什么值导致产
生不好的结果?什么值导致产生良好的结果?
5.现在让我们看看程序test-and-set.s。首先尝试理解使用xchg指令构建简单锁原语
的代码。获取锁怎么写?释放锁如何写?
6.现在运行代码,再次更改中断间隔(-i)的值,并确保循环多次。代码是否总能按
预期工作?有时会导致CPU使用率不高吗?如何量化呢?
7.使用-P标志生成锁相关代码的特定测试。例如,执行一个测试计划,在第一个线程
中获取锁,但随后尝试在第二个线程中获取锁。正确的事情发生了吗?你还应该测试什么?
8.现在让我们看看 peterson.s中的代码,它实现了 Peterson算法(在文中的补充栏中提到)
研究这些代码,看看你能否理解它。
9.现在用不同的-i值运行代码。你看到了什么样的不同行为?
10.你能控制调度(带P标志)来“证明”代码有效吗?你应该展示哪些不同情况?
考虑互斥和避免死锁。
11.现在研究 ticket.s中 ticket锁的代码。它是否与本章中的代码相符?
12，现在运行代码，使用以下标志:-a bx＝1000， b＝-1000（标志设置每个线程循环1000
次）。看看随着时间的推移发生了什么，线程是否花了很多时间自旋等待锁？
13.添加更多的线程，代码表现如何？
14，现在来看yield.s，其中我们假设yield指令能够，一个线程将CPU的控制权交给另
一个线程（实际上，这会是一个OS原语，但为了简化仿真，我们假设有一个指令可以完
成任务）。找到一个场景，其中test-and-set.s浪费周期旋转，但yield.s不会。节省了多少指
令？这些节省在什么情况下会出现？
15，最后来看test-and-test-and-set.s。这把锁有什么作用？与test-and-set.s相比，它实现
了什么样的优点？