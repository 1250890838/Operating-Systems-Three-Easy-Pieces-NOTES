这个有趣(fun)的小作业测试你是否理解多级页表的工作原理。
是的，对于前一句中fun这个词的使用存在一些争议。
运行程序:`paging-multilevel-translate.py`

```
paging-multilevel-translate.py
```

一些基本的假设:

- 页面大小是一个小得不真实的32字节
- 该进程的虚拟地址空间（假设只有一个）为1024页或32 KB
- 物理内存由128页组成

因此，虚拟地址需要15位（偏量为5位，VPN为10位）。 
物理地址需要12位（偏移为5为，PFN为7）。

系统使用一个多级页表。 
因此，虚拟地址的高五位用于索引页面目录。 
页目录项（PDE）（如果有效）指向页表的页面。 
每个页表页包含32个页表项（PTE）。 
每个PTE（如果有效）均保保存问题虚拟页面的所需转换（物理帧号或PFN）。


PTE的格式为：
```
  VALID | PFN6 ... PFN0
```
因此是8位或1字节。


PDE的格式本质上是相同的：
```
  VALID | PT6 ... PT0
```

首先你有两条信息可以获取

首先，为您提供页面目录基址寄存器（PDBR）的值，该值告诉您页面目录位于哪个页面上。

其次，您将获得每个内存页面的完整转储。 页面转储如下所示：
(Second, you are given a complete dump of each page of memory. A page dump
looks like this:) 

```
    page 0: 08 00 01 15 11 1d 1d 1c 01 17 15 14 16 1b 13 0b ...
    page 1: 19 05 1e 13 02 16 1e 0c 15 09 06 16 00 19 10 03 ...
    page 2: 1d 07 11 1b 12 05 07 1e 09 1a 18 17 16 18 1a 01 ...
    ...
```

它显示了在第0、1、2等页上找到的32个字节。 
页面0上的第一个字节（第0个字节）的值为0x08，第二个为0x00，第三个为0x01，依此类推。

然后你会得到一个虚拟地址的列表来进行转换

使用PDBR查找该虚拟页面的相关页表项。 然后找到它是否有效。 
然后进行转换形成最终的物理地址。 使用此地址，您可以找到内存引用正在寻找的值。

当然，虚拟地址可能无效，因此会产生错误

一些有用的参数
```
  -s SEED, --seed=SEED       随机种子
  -n NUM, --addresses=NUM    生成虚拟地址数量
  -c, --solve                计算答案
```

一如既往地更改种子以获得不同的问题。

更改生成的虚拟地址的数量，以便对给定的内存转储进行更多的转换。

使用 -c (或 --solve) 计算解决方案.

